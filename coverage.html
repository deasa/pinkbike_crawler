
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>exporter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">pinkbike-scraper/pkg/exporter/csv_exporter.go (0.0%)</option>
				
				<option value="file1">pinkbike-scraper/pkg/exporter/db_exporter.go (93.3%)</option>
				
				<option value="file2">pinkbike-scraper/pkg/exporter/sheets_exporter.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package exporter

import (
        "encoding/csv"
        "fmt"
        "os"
        "pinkbike-scraper/pkg/listing"
)

type CSVExporter struct {
        goodListingsPath    string
        suspectListingsPath string
}

func NewCSVExporter(goodPath, suspectPath string) *CSVExporter <span class="cov0" title="0">{
        return &amp;CSVExporter{
                goodListingsPath:    goodPath,
                suspectListingsPath: suspectPath,
        }
}</span>

func (e *CSVExporter) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (e *CSVExporter) Export(listings []listing.Listing) error <span class="cov0" title="0">{
        if err := e.writeToFile(listings); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to CSV: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (e *CSVExporter) writeToFile(listings []listing.Listing) error <span class="cov0" title="0">{
        goodFile, err := os.Create(e.goodListingsPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer goodFile.Close()

        suspectFile, err := os.Create(e.goodListingsPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer suspectFile.Close()

        goodWriter := csv.NewWriter(goodFile)
        defer goodWriter.Flush()

        suspectWriter := csv.NewWriter(suspectFile)
        defer suspectWriter.Flush()

        csvHeaders := []string{"Title", "Year", "Manufacturer", "Model", "Price", "Currency", "Condition", "Frame Size", "Wheel Size", "Frame Material", "Front Travel", "Rear Travel", "Needs Review"}

        err = goodWriter.Write(csvHeaders)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = suspectWriter.Write(csvHeaders)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, l := range listings </span><span class="cov0" title="0">{
                row := []string{l.Title, l.Year, l.Manufacturer, l.Model, l.Price, l.Currency, l.Condition, l.FrameSize, l.WheelSize, l.FrameMaterial, l.FrontTravel, l.RearTravel, l.NeedsReview}
                if l.NeedsReview != "" </span><span class="cov0" title="0">{
                        err = suspectWriter.Write(row)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">err = goodWriter.Write(row)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package exporter

import (
        "database/sql"
        "fmt"
        "pinkbike-scraper/pkg/db"
        "pinkbike-scraper/pkg/listing"

        _ "github.com/mattn/go-sqlite3"
)

type DBExporter struct {
        dbWorker *db.DBWorker
}

func NewDBExporter(dbWorker *db.DBWorker) *DBExporter <span class="cov8" title="1">{
        return &amp;DBExporter{dbWorker: dbWorker}
}</span>

func (e *DBExporter) Export(listings []listing.Listing) error <span class="cov8" title="1">{
        tx, err := e.dbWorker.DB.Begin()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        if err := e.exportListings(tx, listings); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := e.markInactiveListings(tx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

func (e *DBExporter) Close() error <span class="cov8" title="1">{
        return e.dbWorker.DB.Close()
}</span>

func (e *DBExporter) exportListings(tx *sql.Tx, listings []listing.Listing) error <span class="cov8" title="1">{
        stmt, err := tx.Prepare(`
        INSERT INTO listings (
            title, year, manufacturer, model, price, currency, 
            condition, frame_size, wheel_size, frame_material,
            front_travel, rear_travel, needs_review, url, hash,
            description, restrictions, seller_type, original_post_date,
            first_seen, last_seen, active
        ) 
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?,
                ?, ?, ?, ?,
                CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, 1)
        ON CONFLICT(hash) DO UPDATE SET 
            last_seen = CURRENT_TIMESTAMP,
            active = 1,
            url = excluded.url,
            price = excluded.price
    `)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to prepare statement: %w", err)
        }</span>
        <span class="cov8" title="1">defer stmt.Close()

        for _, l := range listings </span><span class="cov8" title="1">{
                if err := e.exportListing(stmt, tx, l); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (e *DBExporter) exportListing(stmt *sql.Stmt, tx *sql.Tx, l listing.Listing) error <span class="cov8" title="1">{
        if _, err := stmt.Exec(
                l.Title, l.Year, l.Manufacturer, l.Model, l.Price,
                l.Currency, l.Condition, l.FrameSize, l.WheelSize,
                l.FrameMaterial, l.FrontTravel, l.RearTravel,
                l.NeedsReview, l.URL, l.Hash,
                l.Details.Description, l.Details.Restrictions, l.Details.SellerType, l.Details.OriginalPostDate,
        ); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to insert listing: %w", err)
        }</span>

        <span class="cov8" title="1">return e.recordPriceHistory(tx, l)</span>
}

func (e *DBExporter) recordPriceHistory(tx *sql.Tx, l listing.Listing) error <span class="cov8" title="1">{
        _, err := tx.Exec(`
        INSERT INTO price_history (listing_hash, price, currency)
        SELECT ?, ?, ?
        WHERE NOT EXISTS (
            SELECT 1 FROM price_history 
            WHERE listing_hash = ? 
            AND price = ? 
            AND recorded_at &gt; datetime('now', '-1 day')
        )
    `, l.Hash, l.Price, l.Currency, l.Hash, l.Price)

        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to record price history: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (e *DBExporter) markInactiveListings(tx *sql.Tx) error <span class="cov8" title="1">{
        _, err := tx.Exec(`
        UPDATE listings 
        SET active = 0 
        WHERE datetime(last_seen) &lt; datetime('now', '-7 days')
    `)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to mark inactive listings: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package exporter

import (
        "context"
        "fmt"
        "pinkbike-scraper/pkg/listing"

        "google.golang.org/api/drive/v3"
        "google.golang.org/api/option"
        "google.golang.org/api/sheets/v4"
)

type SheetsExporter struct {
        service       *sheets.Service
        spreadsheetID string
}

func NewSheetsExporter(credentialsFile, spreadsheetID string) (*SheetsExporter, error) <span class="cov0" title="0">{
        ctx := context.Background()
        srv, err := sheets.NewService(ctx, option.WithCredentialsFile(credentialsFile))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sheets service: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SheetsExporter{
                service:       srv,
                spreadsheetID: spreadsheetID,
        }, nil</span>
}

func (e *SheetsExporter) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (e *SheetsExporter) Export(listings []listing.Listing) error <span class="cov0" title="0">{
        if err := e.appendToSheet(listings); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to export to sheets: %w", err)
        }</span>
        <span class="cov0" title="0">return e.removeDuplicates()</span>
}

func (e *SheetsExporter) appendToSheet(listings []listing.Listing) error <span class="cov0" title="0">{
        // Create a new Google Sheets service client
        ctx := context.Background()
        srv, err := sheets.NewService(ctx, option.WithCredentialsFile("pinkbike-exporter-8bc8e681ffa1.json"))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Unable to retrieve Sheets client: %v", err)
        }</span>

        <span class="cov0" title="0">var values [][]interface{}
        for _, l := range listings </span><span class="cov0" title="0">{
                values = append(values, []interface{}{l.Title, l.Year, l.Manufacturer, l.Model, l.Price, l.Condition, l.
                        FrameSize, l.WheelSize, l.FrontTravel, l.RearTravel, l.FrameMaterial, l.NeedsReview, l.Currency, l.URL})
        }</span>

        // Create the value range object
        <span class="cov0" title="0">valueRange := &amp;sheets.ValueRange{
                Values: values,
        }

        // Append the data to the sheet
        appendRange := "Sheet1"
        _, err = srv.Spreadsheets.Values.Append(e.spreadsheetID, appendRange, valueRange).ValueInputOption("USER_ENTERED").
                InsertDataOption("INSERT_ROWS").Do()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Unable to append data to sheet: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SendDeDuplicateRequestToGoogleSheets removes duplicate rows from the Google Sheets document
// NOTE: Only the first match is kept! This means that when a listing's price changes, the old listing and old price will be kept.
func (e *SheetsExporter) removeDuplicates() error <span class="cov0" title="0">{
        // Remove duplicates from the sheet, considering only specific columns
        deleteDuplicatesRequest := &amp;sheets.BatchUpdateSpreadsheetRequest{
                Requests: []*sheets.Request{
                        {
                                DeleteDuplicates: &amp;sheets.DeleteDuplicatesRequest{
                                        Range: &amp;sheets.GridRange{
                                                SheetId:          0,
                                                StartRowIndex:    0,
                                                StartColumnIndex: 0,
                                                EndColumnIndex:   12, // Include columns 0 to 11 (Title to FrameMaterial)
                                        },
                                        ComparisonColumns: []*sheets.DimensionRange{
                                                {
                                                        SheetId:    0,
                                                        Dimension:  "COLUMNS",
                                                        StartIndex: 0, // Title
                                                        EndIndex:   3, // Model
                                                },
                                                {
                                                        SheetId:    0,
                                                        Dimension:  "COLUMNS",
                                                        StartIndex: 6,  // Condition
                                                        EndIndex:   11, // FrameMaterial
                                                },
                                        },
                                },
                        },
                },
        }

        _, err := e.service.Spreadsheets.BatchUpdate(e.spreadsheetID, deleteDuplicatesRequest).Do()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Unable to remove duplicates from sheet: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func createSheetAndShare(ctx context.Context, srv *sheets.Service, title, email, credentialFile string) error <span class="cov0" title="0">{
        sheet, err := srv.Spreadsheets.Create(&amp;sheets.Spreadsheet{
                Properties: &amp;sheets.SpreadsheetProperties{
                        Title: title,
                },
        }).Do()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Unable to create spreadsheet: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Created new spreadsheet: %s\n", sheet.SpreadsheetUrl)

        driveService, err := drive.NewService(ctx, option.WithCredentialsFile(credentialFile))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Unable to retrieve Drive client: %v", err)
        }</span>

        <span class="cov0" title="0">_, err = driveService.Permissions.Create(sheet.SpreadsheetId, &amp;drive.Permission{
                Type:         "user",
                Role:         "writer",
                EmailAddress: email,
        }).Do()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Unable to share spreadsheet: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
